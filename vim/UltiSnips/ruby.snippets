# Global Snippet Helpers

global !p

CONSTANTIZE_REGEX = re.compile(r'(_|^)(.)')

RUBOCOP_COP_NAME_REGEX = re.compile(r'\[(.+)\]')

def Classify(basename):
    def do_transform(match):
      return match.group(2).upper()

    return CONSTANTIZE_REGEX.sub(do_transform, basename)

def ExtractCopName(details):
    match = RUBOCOP_COP_NAME_REGEX.search(details)
    if match:
        return match.group(1)
    return ''

def GetCopName():
    bufnr = vim.current.buffer.number
    cursor = vim.current.window.cursor

    loclist = vim.bindeval('ale#engine#GetLoclist({0})'.format(bufnr))
    if loclist is None:
        return 'unknown'
    matches = [e for e in loclist if e['lnum'] == cursor[0]]
    if matches:
        messages = [str(m['text']) for m in matches]
        cops = [ExtractCopName(text) for text in messages]
        return ' '.join(cops)
    return 'unknown'

endglobal

snippet rdLL "disable rubocop line length" w
# rubocop:disable Metrics/LineLength
endsnippet

snippet rdAbc "disable rubocop abc size" w
# rubocop:disable Metrics/AbcSize
endsnippet

snippet rdMl "rubocop:disable Metrics/MethodLength" w
# rubocop:disable Metrics/MethodLength
endsnippet

snippet rdAM "rubocop:disable Metrics/MethodLength,AbcSize" w
# rubocop:disable Metrics/MethodLength,AbcSize
endsnippet

snippet rd "rubocop:disable" w
# rubocop:disable ${1:`!p snip.rv = GetCopName()`}$0
endsnippet

snippet rea "rubocop:enable All" w
# rubocop:enable all$0
endsnippet

snippet re "rubocop:enable" w
# rubocop:enable $0
endsnippet

snippet aliasm "alias_method" w
alias_method :${1:new_name}, :${2:old_name}$0
endsnippet

snippet alias "alias" w
alias ${1:new_name} ${2:old_name}$0
endsnippet

snippet claself "class << self" w
class << self
	$1
end$0
endsnippet

snippet inc "include '[Module]'" b
include ${1:Module}$0
endsnippet

snippet ext "extend '[Module]'" b
extend ${1:Module}$0
endsnippet

snippet ecla "error class" b
class ${1:MyErrorClass} < ${2:StandardError}${3:; }${3/(; )/(?1::\t)/}$4${3/(; )/(?1::\n)/}end
endsnippet

snippet fsl "frozen_string_literal: true" b
# frozen_string_literal: true
$0
endsnippet

snippet ar "attr_reader" b
attr_reader :${0:attribute}
endsnippet

snippet aw "attr_writer" b
attr_writer :${0:attribute}
endsnippet

snippet aa "attr_accessor" b
attr_accessor :${0:attribute}
endsnippet

snippet ar: "attr_reader (with documentation)" b
# @!attribute [r] $1
${2:#   @return [${3:Type}]} $4
attr_reader :${1:attribute}$0
endsnippet

snippet aw: "attr_writer (with documentation)" b
# @!attribute [w] $1
${2:#   @return [${3:Type}]} $4
attr_writer :${1:attribute}$0
endsnippet

snippet aa: "attr_accessor (with documentation)" b
# @!attribute [rw] $1
${2:#   @return [${3:Type}]} $4
attr_accessor :${1:attribute}$0
endsnippet

snippet au "autoload" b
autoload :${1:Constant}${2:, '${3:path}'}$0
endsnippet

snippet group "Yard Group/End Group Block" b
# @!group ${1:name} {{{
${VISUAL:Contents}$0
# @!endgroup }}}
endsnippet

snippet @p "@param [Type] {docstring}" w
@param ${1:name} [${2:Type}] $0
endsnippet

snippet #p "@param [Type] {docstring}" b
# @param ${1:name} [${2:Type}] $0
endsnippet

snippet @r "@return" w
@return [${1:Type}] $0
endsnippet

snippet @ex "@example" w
@example
endsnippet

# old impl
# module ${1:`!v substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
# 	$0
# end

snippet mod "module ... end" b
module ${1:`!p snip.rv = Classify(snip.basename)`}
	$0
end
endsnippet

snippet modc "module ... end" b
module ${1:`!v substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
	$0

	module ClassMethods
	$4
	end
end
endsnippet

snippet concern "ActiveSupport::Concern" b
module ${1:`!v substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
	extend ActiveSupport::Concern
	${2:
	included do
		$3
	end
	}$0
	module ClassMethods
	$4
	end
end
endsnippet

snippet @attr "Attribute documentation" w
# @!attribute [${1:r|w|rw}] ${2:attribute_name}
${3:#   @return [${4:Type}]} $0
endsnippet

snippet @o "option documentation" w
@option ${1:options} [${2:Type}] :${3:option_name} $0
endsnippet

snippet #o "option documentation, with commentstring" w
# @option ${1:options} [${2:Type}] :${3:option_name} $0
endsnippet

snippet mf "module_function" b
module_function $0
endsnippet

snippet cl "class ... end" b
class ${1:`!p snip.rv = Classify(snip.basename)`}
	$0
end
endsnippet

snippet cla "class ... end" b
class ${1:`!p snip.rv = Classify(snip.basename)`}
	$0
end
endsnippet

snippet clai "class ... def initialize(...) ... end" b
class ${1:`!p snip.rv = Classify(snip.basename)`}
	def initialize(${2:args})
		$0
	end
end
endsnippet

snippet cla< "class ... < ParentClass ... def initialize(...) ... end" b
class ${1:`!p snip.rv = Classify(snip.basename)`} < ${2:ParentClass}
	def initialize(${3:args})
		${4:super}
		$0
	end
end
endsnippet
